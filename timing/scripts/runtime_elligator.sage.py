

# This file was *autogenerated* from the file runtime_elligator.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_251 = Integer(251); _sage_const_9 = Integer(9); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_1175 = Integer(1175); _sage_const_1 = Integer(1); _sage_const_1806494121122717992522804053500797229648438766985538871240722010849934886421 = Integer(1806494121122717992522804053500797229648438766985538871240722010849934886421); _sage_const_3 = Integer(3); _sage_const_1174 = Integer(1174); _sage_const_5 = Integer(5); _sage_const_256 = Integer(256); _sage_const_10 = Integer(10)#!/usr/bin/env sage

# to get this running:
# sage -python3 -m pip install hwcounter


import random
from hwcounter import count, count_end
import argparse

input_data = []
output_data = []

class Curve1174:  # struct in c  # edward curve
    def __init__(self):
        self.q = _sage_const_2 **_sage_const_251  - _sage_const_9 
        self.Fq = GF(self.q)

        # Use Montogomery curve, which is equivalent to the following Edwards curve:
        # x^2 + y^2 = 1 - 1174 * x^2 * y^2
        self.curve = EllipticCurve(self.Fq, [_sage_const_0 , _sage_const_4 /_sage_const_1175 -_sage_const_2 , _sage_const_0 , _sage_const_1 , _sage_const_0 ])

        self.s = self.Fq(_sage_const_1806494121122717992522804053500797229648438766985538871240722010849934886421 )
        self.c = _sage_const_2  / (self.s**_sage_const_2 )
        self.d = -(self.c + _sage_const_1 )**_sage_const_2  / (self.c - _sage_const_1 )**_sage_const_2 
        self.r = self.c + _sage_const_1  / self.c

        # Sanity checks
        assert(self.q % _sage_const_4  == _sage_const_3 )
        assert(self.c * (self.c - _sage_const_1 ) * (self.c + _sage_const_1 ) != _sage_const_0 )
        assert(self.d == -_sage_const_1174 )
        assert(self.r != _sage_const_0 )
        assert(not self.d.is_square())

curve = Curve1174()

def chi(x, q):
    return legendre_symbol(x, q)

def elligator1_map(t):
    if t in [_sage_const_1 , -_sage_const_1 ]:
        return _sage_const_0 , _sage_const_1 

    u = (_sage_const_1  - t) / (_sage_const_1  + t)
    v = u**_sage_const_5  + (curve.r**_sage_const_2  - _sage_const_2 ) * u**_sage_const_3  + u

    chi_v = chi(v, curve.q)
    X = chi_v * u
    Y = (chi_v * v)**((curve.q + _sage_const_1 )/_sage_const_4 ) * chi_v * chi(u**_sage_const_2  + _sage_const_1 /curve.c**_sage_const_2 , curve.q)

    x = (curve.c - _sage_const_1 ) * curve.s * X * (_sage_const_1  + X) / Y
    y = (curve.r * X - (_sage_const_1  + X)**_sage_const_2 ) / (curve.r * X + (_sage_const_1  + X)**_sage_const_2 )

    # Sanity checks
    assert(x**_sage_const_2  + y**_sage_const_2  == _sage_const_1  + curve.d * x**_sage_const_2  * y**_sage_const_2 )
    assert(u * v * X * Y * x * (y + _sage_const_1 ) != _sage_const_0 )
    assert(Y**_sage_const_2  == X**_sage_const_5  + (curve.r**_sage_const_2  - _sage_const_2 ) * X**_sage_const_3  + X)

    return x, y

def elligator1_invmap(x, y):
    assert(y + _sage_const_1  != _sage_const_0 )

    eta = (y - _sage_const_1 ) / (_sage_const_2  * (y + _sage_const_1 ))

    # Two sanity checks
    assert(((_sage_const_1  + eta * curve.r)**_sage_const_2  - _sage_const_1 ).is_square())
    if eta * curve.r == -_sage_const_2 :
        assert(x == _sage_const_2  * curve.s * (curve.c - _sage_const_1 ) * chi(curve.c, curve.q) / curve.r)

    X = -(_sage_const_1  + eta * curve.r) + ((_sage_const_1  + eta * curve.r)**_sage_const_2  - _sage_const_1 )**((curve.q + _sage_const_1 ) / _sage_const_4 )
    z = chi((curve.c - _sage_const_1 ) * curve.s * X * (_sage_const_1  + X) * x * (X**_sage_const_2  + _sage_const_1  / curve.c**_sage_const_2 ), curve.q)
    u = z * X
    t = (_sage_const_1  - u) / (_sage_const_1  + u)

    if t.lift() > (curve.q - _sage_const_1 ) / _sage_const_2 :
        return -t
    return t


def elligator1_invmap_helper(x):
    return elligator1_invmap(x[_sage_const_0 ], x[_sage_const_1 ])

def elligator1_map_prep(reps):
    for rep_ in range(reps):
        input_data.append(curve.Fq((random.randint(_sage_const_1 , _sage_const_2 **_sage_const_256 ))))


def elligator1_invmap_prep(reps):
    for rep_ in range(reps):
        input_data.append(elligator1_map(curve.Fq(random.randint(_sage_const_1 , _sage_const_2 **_sage_const_256 ))))

def runtime(setup_f, f, title, path, sets, reps):
    output_file = open(path, "w")
    output_file.write(title)
    output_file.write("Measurement, Runtime [cycles]\n")

    for set_ in range(sets):
        setup_f(reps)
        start = count()
        for rep_ in range(reps):
            output_data.append(f(input_data[rep_]))
        elapsed = float((count_end() - start)) / float(reps)
        output_file.write(f"{reps}, {elapsed}\n")
        input_data.clear()
        output_data.clear()
    output_file.close()





if __name__ == '__main__':
    # Read arguments
    
    parser = argparse.ArgumentParser()
    
    parser.add_argument("--sets", help="Number of sets",
                        default=_sage_const_10 )
    parser.add_argument("--reps", help="Number of reps",
                        default=_sage_const_10 )
    
    args = parser.parse_args()
    
    sets = args.sets
    reps = args.reps
    
    runtime(elligator1_map_prep, elligator1_map, "sage elligator1 map\n", "../logs/runtime_sage_elligator1_map.log", sets, reps)
    runtime(elligator1_invmap_prep, elligator1_invmap_helper, "sage elligator1 invmap\n", "../logs/runtime_sage_elligator1_invmap.log", sets, reps)

